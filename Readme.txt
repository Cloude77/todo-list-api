// Объяснение handlers/task_handler.go
1)
Этот блок импортирует необходимые пакеты:

database/sql для работы с базой данных.
encoding/json для сериализации и десериализации JSON.
log для логирования ошибок.
net/http для работы с HTTP-запросами и ответами.
strconv для преобразования строк в числа.
time для работы со временем.
todo-list/db для подключения к базе данных.
github.com/gorilla/mux для маршрутизации HTTP-запросов.
todo-list/models для работы с моделями данных.

2) Функция CreateTask

Объявляется переменная newTask типа models.Task.
Запрашивается тело запроса r.Body и декодируется в структуру newTask. Если произошла ошибка при декодировании, отправляется ошибка HTTP 400.
Устанавливается время создания задачи CreatedAt как текущее время.
Создается SQL-запрос для вставки новой задачи в базу данных и возвращения сгенерированного ID.
Выполняется запрос и результат записывается в idCounter. Если произошла ошибка, отправляется ошибка HTTP 500.
Устанавливается заголовок ответа Content-Type как application/json.
Отправляется созданный объект newTask в формате JSON.

3) Функция GetTasks
Эта функция возвращает список всех задач:

Выполняется SQL-запрос для выбора всех задач из базы данных.
Если произошла ошибка при выполнении запроса, отправляется ошибка HTTP 500.
Отложенный вызов defer rows.Close() гарантирует закрытие результата запроса после завершения функции.
Объявляется слайс tasks для хранения указателей на задачи.
Цикл for rows.Next() проходит по всем строкам результата запроса.
Для каждой строки создается переменная task типа models.Task и заполняется данными из строки запроса.
Если произошла ошибка при заполнении данных, отправляется ошибка HTTP 500.
Указатель на task добавляется в слайс tasks.
После цикла проверяется наличие ошибок в результате запроса.
Устанавливается заголовок ответа Content-Type как application/json.
Отправляется слайс tasks в формате JSON.

4) Функция GetTaskByID
Эта функция возвращает задачу по её ID:

Получаются параметры URL с помощью mux.Vars(r).
Извлекается параметр id и преобразуется в целое число. Если преобразование не удалось или ID меньше или равен нулю, отправляется ошибка HTTP 400.
Объявляется переменная task типа models.Task.
Создается SQL-запрос для выбора задачи по ID.
Выполняется запрос и результат записывается в task. Если задача не найдена, отправляется ошибка HTTP 404.
Если произошла другая ошибка, отправляется ошибка HTTP 500.
Устанавливается заголовок ответа Content-Type как application/json.
Отправляется объект task в формате JSON.

5) Функция UpdateTask
Эта функция обновляет существующую задачу:

Получаются параметры URL с помощью mux.Vars(r).
Извлекается параметр id и преобразуется в целое число. Если преобразование не удалось или ID меньше или равен нулю, отправляется ошибка HTTP 400.
Объявляется переменная updatedTask типа models.Task.
Запрашивается тело запроса r.Body и декодируется в структуру updatedTask. Если произошла ошибка при декодировании, отправляется ошибка HTTP 400.
Создается SQL-запрос для обновления задачи по ID.
Выполняется запрос и результат записывается в id. Если произошла ошибка, отправляется ошибка HTTP 500.
Устанавливается заголовок ответа Content-Type как application/json.
Отправляется объект updatedTask в формате JSON.

6) Функция DeleteTask
Эта функция удаляет задачу по её ID:

Получаются параметры URL с помощью mux.Vars(r).
Извлекается параметр id и преобразуется в целое число. Если преобразование не удалось или ID меньше или равен нулю, отправляется ошибка HTTP 400.
Создается SQL-запрос для удаления задачи по ID.
Выполняется запрос без возврата данных.
Если произошла ошибка, отправляется ошибка HTTP 500.
Проверяется количество удаленных строк. Если удаленных строк нет, отправляется ошибка HTTP 404.
Отправляется успешный ответ с кодом состояния HTTP 204 (No Content).


//main.go
1)
import (
    "log"
    "net/http"
    "github.com/gorilla/mux"

    "todo-list/handlers"
)

"github.com/gorilla/mux" github.com/gorilla/mux — это популярная библиотека для маршрутизации HTTP-запросов в Go, которая является частью Gorilla Toolkit.
import: Импортируем необходимые пакеты.
log: Пакет для записи логов (например, сообщений об ошибках или информационных записей).
net/http: Пакет для создания HTTP-сервера и обработки запросов.
"todo-list/handlers": Подключаем пакет handlers, где находятся все обработчики HTTP-запросов (например, CreateTask, GetTasks и т.д.).

2)
    r := mux.NewRouter()

    http.HandleFunc("/tasks", handlers.CreateTask)       // POST /tasks
    http.HandleFunc("/tasks", handlers.GetTasks)         // GET /tasks
    http.HandleFunc("/tasks", handlers.GetTaskByID)      // GET /tasks?id=1
    http.HandleFunc("/tasks", handlers.UpdateTask)       // PUT /tasks?id=1
    http.HandleFunc("/tasks", handlers.DeleteTask)       // DELETE /tasks?id=1

r := mux.NewRouter() — это создание нового маршрутизатора из Gorilla Mux, который предоставляет мощные инструменты для управления HTTP-маршрутами.
http.HandleFunc: Регистрируем обработчики для разных эндпоинтов.
Первый параметр — это URL-шаблон (например, /tasks).
Второй параметр — это функция-обработчик, которая будет вызываться при получении соответствующего запроса.
Здесь мы регистрируем пять обработчиков:
handlers.CreateTask: Обрабатывает запросы POST /tasks для создания новой задачи.
handlers.GetTasks: Обрабатывает запросы GET /tasks для получения списка всех задач.
handlers.GetTaskByID: Обрабатывает запросы GET /tasks?id=1 для получения задачи по ID.
handlers.UpdateTask: Обрабатывает запросы PUT /tasks?id=1 для обновления задачи.
handlers.DeleteTask: Обрабатывает запросы DELETE /tasks?id=1 для удаления задачи.
Важно: Все эти обработчики находятся в пакете handlers, который мы импортировали ранее.

3)
    log.Println("Starting server on :8080")
log.Println: Записываем сообщение в лог. Это поможет нам увидеть, что сервер начал свою работу.
"Starting server on :8080": Сообщение, которое выводится в консоль. Оно говорит, что сервер запущен на порту 8080.

4)
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatal(err)
    }
http.ListenAndServe: Запускаем HTTP-сервер.
Первый параметр (":8080") — это адрес и порт, на которых сервер будет принимать запросы. В нашем случае это localhost:8080.
Второй параметр (nil) — это обработчик запросов. Мы его не указываем, так как все обработчики уже зарегистрированы с помощью http.HandleFunc.
if err := ...: Проверяем, произошла ли ошибка при запуске сервера.
log.Fatal(err): Если возникла ошибка, записываем её в лог и завершаем работу программы.


2)PostgreSQL
Шаг 1: Создание базы данных в PgAdmin
1.1. Открой PgAdmin
1.2. Создание новой базы данных
1.3. Создание таблицы для задач (Используй QueryTools)

Шаг 2: Установка драйвера для PostgreSQL
go get github.com/lib/pq

Шаг3:
# Новый пакет для работы с базой данных db/db.go

package db
Объявляем пакет db. Этот пакет будет содержать функционал для работы с базой данных.
import
database/sql: Стандартный пакет Go для работы с базами данных.
fmt: Для вывода сообщений в консоль.
log: Для записи логов (например, ошибок).
_ "github.com/lib/pq": Импортируем драйвер PostgreSQL. Подчёркивание (_) указывает, что мы импортируем пакет только ради его инициализации, а не для использования конкретных функций.
var DB *sql.DB
Создаём глобальную переменную DB типа *sql.DB. Это будет наше соединение с базой данных.
func ConnectToDB()
Объявляем функцию ConnectToDB, которая будет устанавливать соединение с PostgreSQL.
connStr := "host=localhost port=5432 user=postgres password=your_password dbname=todo_db sslmode=disable"
Создаём строку подключения (connStr) с параметрами:
host: Адрес сервера PostgreSQL (обычно localhost для локальной машины).
port: Порт, на котором работает PostgreSQL (стандартный порт — 5432).
user: Имя пользователя PostgreSQL (например, postgres).
password: Пароль от пользователя PostgreSQL (замените your_password на свой пароль).
dbname: Имя базы данных (todo_db).
sslmode=disable: Отключаем SSL для локальной разработки.
DB, err = sql.Open("postgres", connStr)
Устанавливаем соединение с базой данных, используя драйвер postgres и строку подключения connStr.
Результат сохраняем в глобальную переменную DB.
if err != nil { log.Fatal(err) }
Если возникла ошибка при установке соединения, программа завершится с сообщением об ошибке.
err = DB.Ping()
Проверяем, что соединение с базой данных работает корректно, отправив запрос PING.
if err != nil { log.Fatal(err) }
Если проверка соединения не удалась, программа завершится с сообщением об ошибке.
fmt.Println("Successfully connected to the database!")
Если всё прошло успешно, выведем сообщение в консоль.

Шаг 4: Изменение файла main.go
Теперь нужно вызвать функцию ConnectToDB() при старте приложения.

3)db.go

1) Объяснение:

"database/sql": Стандартный пакет Go для работы с базами данных.
"fmt": Используется для форматирования строк (например, строки подключения).
"log": Пакет для записи логов (например, ошибок или успешного подключения).
"os": Позволяет работать с операционной системой, включая получение переменных окружения.
"github.com/joho/godotenv": Библиотека для загрузки переменных окружения из файла .env.
_"github.com/lib/pq": Драйвер PostgreSQL. Подчёркивание (_) указывает, что мы импортируем пакет только
 ради его инициализации, а не для использования конкретных функций.

2) Глобальная переменная
var DB *sql.DB // Глобальная переменная для соединения с базой данных

 Мы создаем глобальную переменную DB типа *sql.DB. Это будет наше соединение с PostgreSQL.
 Эта переменная доступна во всём пакете db и используется для выполнения SQL-запросов.

3) Функция init()
func init() {}
init() — это специальная функция в Go, которая вызывается автоматически перед запуском программы.
Она используется для выполнения начальной настройки (например, подключения к базе данных).

4) Загрузка переменных окружения
err := godotenv.Load()
  if err != nil {
      log.Println("Error loading .env file")
  }
godotenv.Load() загружает переменные окружения из файла .env в операционную систему.
Если файл .env не найден или произошла ошибка, программа выведет сообщение в лог: "Error loading .env file".
Программа продолжит работу даже если .env отсутствует, так как мы предусмотрели обработку этого случая.

5) Получение параметров из переменных окружения
dbHost := os.Getenv("DB_HOST")
dbPort := os.Getenv("DB_PORT")
dbUser := os.Getenv("DB_USER")
dbPassword := os.Getenv("DB_PASSWORD") // Может быть пустым
dbName := os.Getenv("DB_NAME")

os.Getenv("VAR_NAME") получает значение переменной окружения по её имени.
Мы извлекаем следующие параметры:
dbHost: Адрес сервера PostgreSQL (например, localhost).
dbPort: Порт PostgreSQL (например, 5432).
dbUser: Имя пользователя PostgreSQL (например, postgres).
dbPassword: Пароль пользователя PostgreSQL (может быть пустым).
dbName: Имя базы данных (например, todo_db).
Заметка: Если какой-то параметр отсутствует в .env, функция вернёт пустую строку ("").

6) Формирование строки подключения
var connStr string
if dbPassword == "" {
    // Если пароль не указан, формируем строку без него
    connStr = fmt.Sprintf(
        "host=%s port=%s user=%s dbname=%s sslmode=disable",
        dbHost, dbPort, dbUser, dbName,
    )
} else {
    // Если пароль указан, добавляем его в строку подключения
    connStr = fmt.Sprintf(
        "host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
        dbHost, dbPort, dbUser, dbPassword, dbName,
    )
}

Мы формируем строку подключения к PostgreSQL (connStr) с помощью fmt.Sprintf.
Если dbPassword пустой, строка подключения создаётся без поля password.
Если dbPassword указан, он добавляется в строку подключения.
Почему два варианта?

Это сделано для гибкости. Некоторые конфигурации PostgreSQL могут не требовать пароля
(например, при использовании метода аутентификации trust), поэтому мы учли оба случая.

7) Установка соединения с базой данных
DB, errDB = sql.Open("postgres", connStr)
if errDB != nil {
    log.Fatal(errDB)
}
sql.Open("postgres", connStr) устанавливает соединение с PostgreSQL, используя драйвер postgres и строку подключения connStr.
Результат сохраняется в глобальную переменную DB.
Если возникла ошибка (errDB != nil), программа завершается с сообщением об ошибке (log.Fatal(errDB)).

8) Проверка соединения
errPing := DB.Ping()
if errPing != nil {
    log.Fatal(errPing)
}
DB.Ping() проверяет, что соединение с базой данных работает корректно.
Если проверка не удалась (errPing != nil), программа завершается с сообщением об ошибке.

9) Логирование успешного подключения
log.Println("Successfully connected to the database!")
Если всё прошло успешно, программа записывает сообщение в лог: "Successfully connected to the database!".

10) Итоговая логика
Загружаем параметры подключения из .env.
Формируем строку подключения (connStr), учитывая наличие/отсутствие пароля.
Устанавливаем соединение с PostgreSQL.
Проверяем соединение.
Выводим сообщение об успешном подключении.